## Motivation

This post will show you how to order small multiples in
<span style="font-variant:small-caps;">ggplot2</span> by arbitrary criteria. The
<span style="font-variant:small-caps;">ggplot2</span> library makes it very easy
to draw small multiples: Add either `facet_grid()` or `facet_wrap()` to your code 
and supply a set of (preferably) factors which identifies faceting groups. Done. 
Now <span style="font-variant:small-caps;">ggplot2</span> will display facets in 
the order of the factor levels provided. In other words, if you want to order
small multiples by arbitrary criteria, you will have to reorder the
defining factor levels.

## Setting

```{r, toydata, cache=TRUE, eval=TRUE, echo = FALSE}
rm(list = ls())

# Set population level parameters
n_districts <- 12 # number of school districts
n_students <- 100 # number of students per district
rho <- .4 # mean effect of spending
    
# Draw district level correlation r
r <- rnorm(n_districts, psych::fisherz(rho))
r <- psych::fisherz2r(r)

# Draw district level data
ses_data <- data.frame()
for(i in r){
    Sigma <- matrix(c(1, i, i, 1), 2, 2)
    ses_data <- rbind.data.frame(ses_data, MASS::mvrnorm(n_students, c(0, 0), Sigma))
}
rm(i, Sigma)
names(ses_data) <- c("ses", "success")
ses_data[, "district_id"] <- rep(letters[seq(n_districts)], each = n_students)
```

Assume you have received data that describe the impact of that socioeconomic
status has on student success. The data nest students in school districts. You
want to: (1) Plot the relationship for each school district; (2) Order districts
by the magnitude of the correlation (such that you might hypothesize possible similiarities between districts). Here is what your data[^1] looks like: 

```{r, showData, echo = FALSE}
head(ses_data)
```

[^1]: Look ahead to the end of this post to see how the data were generated.

## Recipe

In our toy data, small multiples are defined by the variable
<span style="font-variant:small-caps;">district_id</span>. Its
levels should be ordered the within-district correlation between
student success and socio-economic status. We need to (1) compute said
correlation, (2) reorder district levels by its value, and (3) plot the
data.

```{r, simpleplot, cache = TRUE, eval = TRUE}
# Step (1): Calculate the within district correlation
r_district <- vector("numeric", length(unique(ses_data[["district_id"]])))
names(r_district) <-  unique(ses_data[["district_id"]])
for(i in names(r_district)){
    filter <- which(ses_data$district == i)
    r_district[i] <- cor(ses_data[filter, "ses"], ses_data[filter, "success"])
}

# Step (2): Reorder the factor levels
ses_data <- within(ses_data,
    district_id <- factor(
        district_id, levels = names(r_district)[order(r_district)]
    )
)

# Step (3): Plot the data
library("ggplot2")
p <- ggplot(data = ses_data, aes(x = ses, y = success)) +
    geom_point() + geom_smooth(method = "lm") +
    facet_wrap(vars(district_id))
print(p)
```

## Conclusion

In this post you have seen how small multiples in
<span style="font-variant:small-caps;">ggplot2</span> can be ordered by
arbitrary criteria. Although the example here was constrained to
`facet_wrap()` and a single grouping factor, the approach generalizes.
No matter what wrapping function or how many facets you define: The
order of you small multiple plots ultimately depends on the order of
your factor levels.

## Toy Data Creation
```{r, test, cache=TRUE, eval=FALSE, dpi=100}
# Set population level parameters
n_districts <- 12 # number of school districts
n_students <- 100 # number of students per district
rho <- .4 # mean effect of spending
    
# Draw district level correlation r
r <- rnorm(n_districts, psych::fisherz(rho))
r <- psych::fisherz2r(r)

# Draw district level data
dta <- data.frame()
for(i in r){
    Sigma <- matrix(c(1, i, i, 1), 2, 2)
    dta <- rbind.data.frame(dta, MASS::mvrnorm(n_students, c(0, 0), Sigma))
}
rm(i, Sigma)
names(dta) <- c("spending", "success")
dta[, "district_id"] <- rep(seq(n_districts), each = n_students)
```

